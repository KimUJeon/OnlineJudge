import sys

n = int(sys.stdin.readline().rstrip())
nums = [0] * 10001

for _ in range(n):
	num = int(sys.stdin.readline().rstrip())
	nums[num] += 1

for i in range(10001):
	if nums[i] != 0:
		for j in range(nums[i]):
			print(i)

'''
이번 문제는 브론즈 1티어 문제 + 수 정렬이라는 아주 간단한 난이도의 문제 같아 보이지만
메모리와 시간 제한이 있다는 점을 감안하면 브론즈 난이도에서 진짜 <알고리즘> 문제 풀이에
근접한 문제라고 볼 수 있을 것 같다

메모리와 시간을 극한으로 낮추기 위해 sort 내장함수를 사용하지 않고 문제를 풀어야 하는데
이를 위해, <계수 정렬> 을 활용하여야 한다.

문제의 입력 부분을 잘 읽어 보면 "둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 10,000보다 작거나 같은 자연수이다."
라고 하는데 이는 중복값이 입력되고 숫자가 아무리 많이 입력되어 봐야 10000개를 넘을 수 없어
기본 배열을 10000개가 들어갈 수 있도록 초기화 해 준 것이다.

10000개가 들어간다면서 왜 배열은 10001개 인가요? 라는 의문이 드는 초보자가 있을 수 있는데 <자연수> 라고 했고
8번 코드를 보면 입력된 숫자를 인덱스로 이용해 입력된 횟수를 +1 하는 방식이기 때문에 맨 처음 시작하는 0을 제외하고
그 이후로 10000개를 넣어줘야 하기 때문에 0번 인덱스는 공간은 만들어주지만 사용하지 못하는 버리는 부분이기 때문이다.

요약하자면 인덱스는 항상 0부터 시작하지만 자연수는 1부터 시작한다 그렇지만 우리가 적용할 해결방법은
인덱스와 입력숫자가 일치해야 하고 이러한 갭을 맞춰주기 위해선? 단순히 배열 크기를 늘려 시작 부분을 맞춰주면 해결 된다.

필자도 알고리즘 문제 풀이가 익숙치 않아 상당히 많이 틀린 문제다...
'''